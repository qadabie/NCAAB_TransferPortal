import pandas as pd
import networkx as nx
from collections import Counter

import matplotlib.pyplot as plt

# Load the data
df = pd.read_parquet('combined_22_25_game_nodes.parquet')

def create_game_networks(game_id, team_id):
    """
    Create directed networks from possession summaries for a specific game,
    generating separate networks for home and away teams.
    
    Args:
        game_id: The ID of the game to analyze
    
    Returns:
        Two network graphs (home_network, away_network)
    """
    # Filter the dataframe for the specific game
    game_df = df[df['game_id'] == game_id]
    
    if game_df.empty:
        print(f"No data found for game_id: {game_id}")
        return None, None
    
    # Get team IDs
    team_id = game_df['team_id'].iloc[0]
    
    # Create empty dictionaries to store edges
    home_edges = []
    
    # Process each possession summary
    for _, row in game_df.iterrows():
        team_id = row['team_id']
        poss_summary = list(row['poss_summary'])
        
        # Skip if possession summary is empty or not a list
        if not isinstance(poss_summary, list) or len(poss_summary) < 2:
            print(f"Skipping row with insufficient possession summary for game_id {game_id} and team_id {team_id}")
            continue

        # Create directed edges from consecutive pairs in the possession summary
        for i in range(len(poss_summary) - 1):
            source = poss_summary[i]
            target = poss_summary[i + 1]
            edge = (source, target)
            
            # Add edge to the appropriate list based on team ID
            if team_id == team_id:
                home_edges.append(edge)
    
    # Count edge frequencies
    home_edge_counts = Counter(home_edges)
    #print(f"Home edges for game_id {game_id} and team_id {team_id}: {home_edge_counts}")
    # Create directed graphs
    home_network = nx.DiGraph()
    # Find nodes with most connections
    all_edges = list(home_edge_counts.keys())
    all_nodes = set([node for edge in all_edges for node in edge])
    node_connections = {str(node): 0 for node in all_nodes}

    for (source, target), weight in home_edge_counts.items():
        node_connections[source] += weight
        node_connections[target] += weight

    # Filter for player nodes that start with "4" and get top 6
    player_nodes = [node for node in node_connections.keys() 
                   if node.startswith('4')]
    top_players = sorted(player_nodes, key=lambda x: node_connections[x], reverse=True)[:6]

    # Only include top players and points nodes
    nodes_to_include = set(top_players)
    points_nodes = [node for node in all_nodes if isinstance(node, str) and node.endswith('_points')]
    shot_nodes = [node for node in all_nodes if isinstance(node, str) and node.endswith('_shot')]
    nodes_to_include.update(points_nodes)
    nodes_to_include.update(shot_nodes)
    # Convert nodes_to_include to a list to maintain order
    nodes_list = list(nodes_to_include)
    # Load player and team tables into dictionaries
    player_table = pd.read_csv('player_table.csv')  # Adjust path as needed
    team_table = pd.read_csv('team_table.csv')      # Adjust path as needed

    # Create player dictionary (player_id -> player_name)
    player_dictionary = dict(zip(player_table.iloc[:, 0].astype(str), player_table.iloc[:, 1]))

    # Create team dictionary (team_id -> team_name)
    team_dictionary = dict(zip(team_table.iloc[:, 0].astype(str), team_table.iloc[:, 1]))

    # Transform player nodes with player names
    nodes_list_transformed = []
    for node in nodes_list:
        if isinstance(node, str) and node.startswith('4'):
            # If the node is a player ID, replace with player name if available
            player_id = node
            nodes_list_transformed.append(player_dictionary.get(player_id, player_id))
        else:
            nodes_list_transformed.append(node)

    # Update nodes_list with transformed values
    nodes_list = nodes_list_transformed

    # Get team name for the title
    team_name = team_dictionary.get(str(team_id), f"Team {team_id}")
    # Create a color list with all of the corresponding colors for each node
    node_colors = []
    for node in nodes_list:
        if isinstance(node, str) and node.endswith('_points'):
            if node == '0_points':
                node_colors.append('red')
            else:
                node_colors.append('green')
        elif isinstance(node, str) and node.endswith('_shot'):
            node_colors.append('lightblue')
        elif node in top_players:
            node_colors.append('orange')
        else:
            node_colors.append('lightgray')
    # Create the filtered graph
    home_network.add_nodes_from(nodes_list)
    # Add edges with weights
    # Filter to only include edges where both source and target are in nodes_list
    filtered_edge_counts = {
        (source, target): weight 
        for (source, target), weight in home_edge_counts.items()
        if source in nodes_list and target in nodes_list
    }
    # Add edges with weights from the filtered edge counts
    for (source, target), weight in filtered_edge_counts.items():
        home_network.add_edge(source, target, weight=weight)
    # Create a layered layout with points at bottom, shots in middle, and players on top
    pos = {}
    
    # Position points nodes at the bottom (row 0)
    
    points_x_positions = {node: idx for idx, node in enumerate(points_nodes)}
    points_width = len(points_nodes)
    for node in points_nodes:
        pos[node] = (points_x_positions[node] - points_width/2, 0)
    
    # Position shot nodes in the middle (row 1)
    shot_x_positions = {node: idx for idx, node in enumerate(shot_nodes)}
    shot_width = len(shot_nodes)
    for node in shot_nodes:
        pos[node] = (shot_x_positions[node] - shot_width/2, 1)
    
    # Position player nodes at the top (row 2)
    player_nodes_list = sorted([node for node in nodes_list if node in top_players])
    player_x_positions = {node: idx for idx, node in enumerate(player_nodes_list)}
    player_width = len(player_nodes_list)
    for node in player_nodes_list:
        pos[node] = (player_x_positions[node] - player_width/2, 2)
    # Visualize the networks
    plt.figure(figsize=(15, 7))
    
    # Home team network
    plt.subplot(1, 1, 1)
    plt.title(f'Home Team ({team_name}) Network - {len(home_network.nodes())} nodes')
    print(f"Number of nodes in home network: {len(home_network.nodes())}")
    pos_home = nx.random_layout(home_network, seed=42)
    edge_weights = [home_network[u][v]['weight']*0.5 for u, v in home_network.edges()]
    #print(home_network['1_points'])
    #color_map = [home_network[node]['color'] for node in list(home_network.nodes())]
    
    nx.draw_networkx(
        home_network, 
        pos,
        with_labels=True, 
        node_color = node_colors,
        node_size=800, 
        font_size=8,
        width=edge_weights,
        arrows=True,
        arrowsize=10
    )
    plt.title(f'Home Team ({team_id}) Network')
    plt.show()
    
    return home_network

# Example: Create networks for the first game in the dataset
first_game_id = df['game_id'].iloc[0]
first_team_id = df['team_id'].iloc[0]
print(f"Creating networks for game_id: {first_game_id}")
home_net = create_game_networks(first_game_id, first_team_id)